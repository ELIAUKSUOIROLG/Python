### 作者：张鑫

## 前言

  - python历史：

            1989年的圣诞节期间，吉多·范罗苏姆（Guido van Rossum）为了在阿姆斯特丹打发时间，决
定开发一个新的脚本解释语言，作为ABC语言的后裔。
        那个年代流行的是Pascal、C、Fortran等编程语言，设计这些语言的初衷就是为了让机器运行
得更快。而为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出符合计算机口味的
程序。吉多知道如何使用C语言写出自己想要的功能，但是整个编写过程很烦琐，需要耗费大量的
时间，他对这种编程方式感到苦恼。那时候Unix的管理员用Shell去编写一些简单的脚本以进行一些
重复的系统维护工作，比如数据备份、用户管理等。Shell可以只使用几行就实现许多C语言下上百
行的程序，然而Shell只是调用命令，并不能调用计算机的所有功能。
吉多希望有一种编程语言能实现像C语言那样全面调用计算机的功能接口，同时又可以像Shell
那样轻松编程。当时他在荷兰国家数学与计算机科学研究中心工作，并参与ABC语言的开发。开发
ABC语言的目的是教导非专业的程序员学习如何开始写程序，ABC语言希望让语言变得容易阅读、
容易使用、容易记忆、容易学习，并以此来激发人们学习编程的兴趣。
        在吉多本人看来，ABC语言非常优雅和强大，并且还是专门为了非专业程序员而设计的。但
是ABC语言的设计还存在一些致命的问题，比如可扩展性差，不能直接操作文件系统等。最终ABC
语言并没有成功，究其原因，吉多认为是这种语言的非开放性造成的。他决心在Python中避免这一
错误，并在后来获取了非常好的效果。
        1991年，Python的第一个版本在吉多的Mac机上诞生了。它是用C语言实现的，并且能够调用C
语言的库文件，完美结合了C语言和Shell的特点。

  - python设计哲学与应用范围：

    Python开发者的设计哲学是“用一种方法，最好是只有一种方法来做一件事”。在设计Python语言时，

    如果面临多种选择，Python开发者一般会拒绝花俏的语法，而选择明确的、没有或者很少有歧义的语法。由于这种设计观念的差异，Python源代码通常具备更好的可读性，并且能够支撑大规模的软件开发。

    

    - python能做什么？

      ◇ 网站后台
   Python有大量成熟的Web框架，如Django、Flask、Bottle、Tornado等。

◇ 网络爬虫
   知名的Scrapy爬虫框架就是用Python实现的，只需要几行代码就能实现一个复杂的爬虫
   项目。

◇ 科学计算
   Python有像NumPy、Pandas这样的科学计算库，完全可以代替R语言和MATLAB。

◇ 机器学习

         通用机器学习可以使用sklearn，深度学习有谷歌的TensorFlow和脸书的PyTorch，这些都是 
   业界最流行的Python机器学习框架。就连著名的阿尔法围棋（AlphaGo）也是使用Python编
   写的。

◇ 大数据
   Spark和Hadoop都开发了Python的接口，所以用Python处理大数据非常方便。

◇ 系统运维
   流行的Linux操作系统无论是Ubuntu还是CentOS都预装Python，方便系统维护人员使用。  

## 基础内容：

  ### 注释：
    - 注释的作用：通过用自己熟悉的语言，在程序中对某些代码进行标注说明，能够大大增强程序的可读性。
    - 单行注释，只能注释一行内容，语法如下：

```Python
# 单行注释
```

        ![](https://secure2.wostatic.cn/static/vi9DiJDPy3jBvT8fv5UPex/image.png)
    - 多行注释，可以注释多行内容，一般用于注释一段代码，语法如下：

```Python
"""(''')    多行注释用英文单引号或双引号
   第一行注释 
   第二行注释
   第三行注释
"""(''')

```

    

  ### 变量

    #### 基础：
      - 
      - 定义：为了更快速的查找和使用我们临时存储在内存中的数据，我们把这个数据在内存中存储之后定义一个名称，
这个名称就是变量。
      - 定义变量：

```Python
sum = 1
# 变量名=值

```

    #### 变量类型：

      #### 数字：
        - 整型：

```Python
>>> 3 + 2
5
>>> 8-6
2
>>> 16-3 * 2
10

```
        - 浮点型：

```Python
>>> (17-2) / 5
3.0
>>> 8 / 5
1.6
```
        - 复数型：

```Python
>>> (3+4j)+(3+4j)
(6+8j)
>>> (3+4j)*2
(6+8j)
```

      #### 字符串：

        

        - 表示与转义
          - 在Python中可以使用“''”（单引号）或“""”（双引号）括起来代表字符串，

```Python
>>> 'How are you'
'How are you'

```

          

          - 也可以使用“\”（反斜线）操作符来对特殊字符转义。

```Python
>>> 'I\'m fine'
"I'm fine"
>>> "I'm fine"
"I'm fine"
```

          

          - 不希望字符被“\”转义，我们可以在字符串引号前加上一个“r”

```Python
>>> print("c:\windows\name") # 注意\n 会被转义成换行符
c:\windows
ame
>>> print(r"c:\windows\name")
c:\windows\name
```

          

          - 表示多行字符串，我们可以使用“ """…""" ”三个双引号或“ '''…''' ”三个单引号把字符串括起来。

```Python
print("""\
How are you?
I'm fine.
""")
```

        

        - 叠加与重复

          

          - Python中可以使用“+”来连接两个字符串，使用“*”来重复字符串。

```Python
>>>3 * 'am' + 'fine'
'amamamfine'
```

          

          - 两个或者多个字符串相邻，解释器会自动合并字符串。

```Python
>>>'Py' 'thon'
'Python'
```

          

          - 注意这只适合在两个文字之间，不能用在字符串或表达式之间。

```Python
>>> (3 * 'am') 'fine'
SyntaxError: invalid syntax
```

          

          - 接两个变量或者一个变量和一个字面量，请使用“+”操作符。

```Python
>>> prefix = 'Py'
>>> prefix +  'thon'
'Python'
```

        

        - 索引与切片

          

          - Python可以很方便地使用“索引”的方式获取到字符串中某个位置的字符

```Python
>>> word = 'Python'
>>> word [0]
'P'
>>> word [5]
'n'
```

          

          - 若索引是负数，那么就会从字符串的右边开始往左计算位置
（注意：-0和0都表示第一个字符，倒序从下标-1开始）

```Python
>>> word = 'Python'
>>> word [-1]
'n'
>>> word [-2]
'o'
>>> word [-6]
'P'
```

          

          - 如果我们想获取字符串中的一段字符串，我们可以使用一种叫作“切片”的操作

```Python
>>> word = 'Python'
>>> word [0:2]
'Py'
>>> word [2:5]
'tho'

```

          

          - 如果省略方括号中“:”左边的数字，Python就会认为我们要获取从0开始的字符串。
如果省略方括号中“:”右边的数字，那么Python会认为我们要获取到最后一个字符。

```Python
>>> word = 'Python'
>>> word [:2]
'Py'
>>> word [2:]
'thon'
>>> word [2:] + word [:2]
'thonPy'
>>> word [:]
'Python'
>>> word [-2:]
'on'
```

          

          - 切片工作原理的一种方式是将索引视为字符间的指向，第一个字符的左边缘编号为0，
然后，一串n个字符的最后一个字符的右边缘具有索引n，例如：

```text
+---+---+---+---+---+---+
| P | y | t | h | o | n |
+---+---+---+---+---+---+
 0  1   2   3   4   5   6
   -6  -5  -4  -3  -2  -1
```

          

          - 索引word [i:j]表示从i到j的片段，由标记为i和j的边缘之间所有的字符组成，
如下所示，word [1:3]为“yt”。

```text
+---+---+---+---+---+---+
| P | y | t | h | o | n |
+---+---+---+---+---+---+
| 0 | 1 | 2 | 3 | 4 | 5 |
```

              对于非负数指数，如果两者都在边界内，那么切片的长度就是指数的差值。
例如，word [1:3]的长度是2

          

          - 如果索引超出了原来字符串的长度，那么Python解释器将会报错。

```Python
>>> word [100]
IndexError: string index out of range
```

          

          - 但是如果使用的是切片方式，Python解释器就会忽略这个错误。

```Python
>>> word [4:100]
'on'
>>> word [100:]
''
```
          - 在Python中，字符串是不能被改变的，无论是索引还是切片方式都只能获取字符串而不能被
赋值

          

          - Python有个内置函数“len()”，它可以返回字符串的长度

```Python
>>> len('word')
4
>>> w='你好'
>>> len(w)
2
```

  ### 标识符：

    #### 命名规则
      - 由数字、字母、下划线组成
      - 不能由数字开头
      - 严格区分大小写

    #### 关键字（补充）
      - **def：**用于定义函数或方法

          ![](https://secure2.wostatic.cn/static/knVUErz798q37Q8K3C4AhV/image.png)
      - **for：**for循环语句
      - **import：**用于导入模块，与form结合使用

```Python
import turtle
# 引入turtle 
# 再该模块中我们可以创建
```

          [https://blog.csdn.net/qq_50531498/article/details/114107466](https://blog.csdn.net/qq_50531498/article/details/114107466)

      

  ### 运算符：

    - 算术运算符：
      - 定义：
算术运算符用在数学表达式中，作用和在数学中的作用是一样的
      - 常见操作符

          ![](https://secure2.wostatic.cn/static/5s1Lki8vgv3LMxxgGhAPTc/运算符.png)

      

      - 实践

```Python
>>> a = 10
>>> b = 20
>>> c = 7
>>> d = 25
>>> a + b
30
>>> a + b + c
37
>>> a - b
-10
>>> a - b - c
-17
>>> a * b
200
>>> a * b * c
1400
>>> a / b
0.5
>>> a / b / c
0.07142857142857142
>>> a % b
10
>>> a ** c
10000000
>>> a // b
0
>>> d // c
3
```

    - 比较运算符：
      - 定义：
比较运算符是指对符号两边的变量进行比较的运算符，包括比较大小、相等、真假等。
如果比较结果是正确的，返回True（真），否则返回False（假）。
      - 常见比较运算符：

          ![](https://secure2.wostatic.cn/static/3fUnriGfo3FRFpE57GmuYJ/image.png)
      - 实践：

```Python
>>> a = 123
>>> a < 100
False
>>> a > 100
True
>>> a <= 200
True
>>> a <= 123
True
>>> a == 123
True
>>> a != 123
False
>>> a == 100
False
```

    - 赋值运算符：
      - 定义：最常用的赋值运算符是“=”（等于号），表示把右边的结果值赋值给左边的变量。其他的赋
值运算符大多都是算术运算符和赋值运算符的简写。


      - 常见赋值运算符：

          ![](https://secure2.wostatic.cn/static/tdTdK9PdXhyZbce9kC56Ns/image.png)

          ![](https://secure2.wostatic.cn/static/vwk5GqsAKWBvXhxykevE2V/image.png)
      - 实践：

```Python
>>> a = 100
>>> a
100
>>> a += 10
>>> a
110
>>> a -= 10
>>> a
100
>>> a *= 10
>>> a
1000
>>> a /= 10
>>> a
100.0
>>> a %= 10
>>> a
0.0
>>> a = 100
>>> a **= 2
>>> a
10000
>>> a //= 9
>>> a
1111
```

    - 位移运算符：
      - 定义：

          Python定义了位运算符，它应用在两个数的运算上，会对数字的二进制所有位数进行从低到高
的运算。

          
      - 常见位运算符：

          ![](https://secure2.wostatic.cn/static/r5ytCGpsMaVZBK29WuxABw/image.png)

      

      - 实践：

```Python
>>> a = 9
>>> b = 13
>>> a & b
9
>>> a | b
13
>>> a ^ b
4
>>> ～a
-10
>>> a << 2
36
>>> b >> 2
3
```

    - 逻辑运算符：
      - 定义：逻辑运算符在Python中非常重要，它广泛应用在逻辑判断上。

      

      - 常见逻辑运算符：

          ![](https://secure2.wostatic.cn/static/5hmmFqNtveKHj8rqKRJtuV/image.png)

      

      - 实践

```Python
>>> True and True
True
>>> True and False
False
>>> True or False
True
>>> not False
True
```

      

## 数据结构：

  ### 通用序列操作：

    #### 索引：
      - Python中的索引从“0”开始计数，第一个是“0”，第二个是“1”，以此类推

```Python
# 列表
x1 = [1, 2, 3, 4]
print("列表") 
print(x1 [0])
print(x1 [1])
print("---------")
# 元组
x2 = (1, 2, 3, 4)
print("元组")
print(x2 [0])
print(x2 [1])

执行结果如下：

列表
1
2
---------
元组
1
2

#序列中的元素是从“0”开始从左往右编号的，元素通过编号进行访问
#索引使用的语法都是一样的：变量后面加中括号，在括号中输入所需元素的编号
```
      - 在Python中，索引非常灵活，不仅可以从左往右编号，还可以从右往左编号

```Python
# 列表
x1 = [1, 2, 3, 4]
print("列表")
print(x1 [-1])
print(x1 [-2])
print("---------")
# 元组
x2 = (1, 2, 3, 4)
print("元组")
print(x2 [-1])
print(x2 [-2])

执行结果如下：

列表
4
3
---------
元组
4
3

#从执行结果中我们可以看到，Python也可以从右边往左边索引，只要在前面加个“-”（负号）即可。
```

      

    #### 切片：

      - 1：
        - 在Python中不是只有列表和字符串可以进行切片操作，而是所有的序列类型都可以进行切片操作。

```Python
# 列表
x1 = [1, 2, 3, 4]
print("列表")
print(x1 [0:3])
print(x1 [2:3])
print("---------")

# 元组
x2 = (1, 2, 3, 4)
print("元组")
print(x2 [0:3])
print(x2 [2:3])
print("---------")

# 字符串
x3 = "1234"
print("字符串")
print(x3 [0:3])
print(x3 [2:3])

```
        - 执行结果如下：

```Python
列表
[1, 2, 3]
[3]
---------
元组
(1, 2, 3)
(3,)
---------
字符串
123
3
```
        - 从执行结果中我们可以看出切片操作的实现需要提供两个索引作为边界，
第一个索引的元素包含在切片内（闭区间），第二个索引的元素不包含在切片内（开区间）。
类似于数学区间“ [a, b)”，a是切片第一个参数，b是切片第二个参数，b不包含在切片中。

      - 2：
        - 同样地，切片也支持负数，也就是按从右往左的顺序的索引获取切片。（这个与之前的原理一样）

```Python
# 列表
x1 = [1, 2, 3, 4]
print("列表")
print(x1 [-3:3])
print("---------")
# 元组
x2 = (1, 2, 3, 4)
print("元组")
print(x2 [-3:3])
print("---------")
# 字符串
x3 = "1234"
print("字符串")
print(x3 [-3:3])
```
        - 执行结果如下：

```Python
列表
 [2, 3]
---------
元组
(2, 3)
---------
字符串
```
        - 这个例子与之前的原理一样

```text
+---+---+---+---+
| 1 | 2 | 3 | 4 |
+---+---+---+---+
  0   1   2    3
 
 -4  -3  -2  -1
```

      - 3：
        - 序列的索引下标可以超出其真实的索引长度

```Python
# 列表
x1 = [1, 2, 3, 4]
print("列表")
print(x1 [3:10])
print("---------")
# 元组
x2 = (1, 2, 3, 4)
print("元组")
print(x2 [3:10])
print("---------")
# 字符串
x3 = "1234"
print("字符串")
print(x3 [3:10])
```
        - 执行结果如下：

```Python
列表
[4]
---------
元组
(4,)
---------
字符串
4
```

      - 4：
        - 所有的序列的切片都有个默认的“a”“b”值（这里的“a”和“b”对应前面例子中所说“第一个参数”和“第二个参数”）
即“a”的默认值是0，“b”的默认值是到序列的最后（包含最后一个元素）

```Python
# 列表
x1 = [1, 2, 3, 4]
print("列表")
print(x1 [3:])
print(x1 [:3])
print("---------")
# 元组
x2 = (1, 2, 3, 4)
print("元组")
print(x2 [3:])
print(x2 [:3])
print("---------")
# 字符串
x3 = "1234"
print("字符串")
print(x3 [3:])
print(x3 [:3])
```
        - 执行结果如下：

```Python
列表
[4]
[1, 2, 3]
---------
元组
(4,)
(1, 2, 3)
---------
字符串
4
123
```

      - 5：
        - 如果切片的两个索引都设置为空，那自然获取整个序列。

```Python
# 列表
x1 = [1, 2, 3, 4]
print("列表")
print(x1 [:])
print("---------")
# 元组
x2 = (1, 2, 3, 4)
print("元组")
print(x2 [:])
print("---------")
# 字符串
x3 = "1234"
print("字符串")
print(x3 [:])
```
        - 执行结果如下：

```Python
列表
 [1, 2, 3, 4]
---------
元组
(1, 2, 3, 4)
---------
字符串
1234


#结果中输出的是整个序列
```

      - 6：
        - 获取非连续的序列，Python的切片提供了第三个参数：步长。默认情况下步长为“1”。

```Python
# 列表
x1 = [1, 2, 3, 4, 5, 6, 7]
print("列表")
print(x1 [1:5])
print(x1 [1:5:1])
print("---------")
# 元组
x2 = (1, 2, 3, 4, 5, 6, 7)
print("元组")
print(x2 [1:5])
print(x2 [1:5:1])
print("---------")
# 字符串
x3 = "1234567"
print("字符串")
print(x3 [1:5])
print(x3 [1:5:1])
```
        - 执行结果如下：

```Python
列表
 [2, 3, 4, 5]
 [2, 3, 4, 5]
---------
元组
(2, 3, 4, 5)
(2, 3, 4, 5)
---------
字符串
2345
2345

```

      - 7：
        - 设置步长为“1”和不设置步长是一样的，说明默认步长为“1”。
如果设置步长为“2”，则得到的序列是从开始到结束每隔“1”个元素的序列。

```Python
# 列表
x1 = [1, 2, 3, 4, 5, 6, 7]
print("列表")
print(x1 [1::2])
print(x1 [1::3])
print("---------")
# 元组
x2 = (1, 2, 3, 4, 5, 6, 7)
print("元组")
print(x2 [1::2])
print(x2 [1::3])
print("---------")
# 字符串
x3 = "1234567"
print("字符串")
print(x3 [1::2])
print(x3 [1::3])
```
        - 执行结果如下：

```Python
列表
[2, 4, 6]
[2, 5]
---------
元组
(2, 4, 6)
(2, 5)
---------
字符串
246
25

```
        - 从以上执行结果可以看出，使用步长的方式是很灵活的，只需在切片后再添加“:”并输入想
要的步长即可。不过需要注意的是，步长参数不支持“0”
        - 那步长可以是负数吗？
同学们不妨自己在程序中试一试。

      

      

      

      

      

      

      

      

      

      

      

      

    #### 序列相加：

      - 1:
        - 序列之间可以使用“+”（加号）进行连接操作

```Python
# 列表
x1 = [1, 2, 3,] + [ 4, 5, 6, 7]
print("列表")
print(x1)
print("---------")
# 元组
x2 = (1, 2, 3,) + (4, 5, 6, 7)
print("元组")
print(x2)
print("---------")
# 字符串
x3 = "123" + "4567"
print("字符串")
print(x3)
```
        - 执行结果如下：

```Python
列表
[1, 2, 3, 4, 5, 6, 7]
---------
元组
(1, 2, 3, 4, 5, 6, 7)
---------
字符串
1234567
```

      - 2:
        - 序列和序列之间通过加号连接，连接后的结果还是相同类型的序列，
但是要注意不同类型的序列是不能做连接的。

```Python
# 错误
[1, 2, 3] + (1, 2, 3)
"123" + [1, 2, 3]
(1, 2, 3) + "123"

#Python解释器只能在相同类型的序列之间做连接操作
```

    #### 序列重复：
      - Python中，序列不仅可以做“加法”，还可以使用“*”（星号）做“乘法”。

```Python
# 列表
x1 = [1, 2, 3,] * 5
print("列表")
print(x1)
print("---------")
# 元组
x2 = (1, 2, 3,) * 5
print("元组")
print(x2)
print("---------")
# 字符串
x3 = "123" * 5
print("字符串")
print(x3)

```
      - 执行结果如下：

```Python
列表
 [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
---------
元组
(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3)
---------
字符串
123123123123123
```

    #### 成员资格：

      - 1：
        - 成员资格指判断一个元素是否包含在序列中，Python中使用运算符“in”来判断。
“in”运算符会判断左边的元素是否包含在右边的序列中，如果包含就会返回True（真），
如果不包含则会返回False（假）。

```Python
# 列表
print("列表")
print(5 in [1, 2, 3, 4, 5, 6, 7])
print("Hi" in [1, 2, 3, 4, 5, 6, 7])
print("---------")
# 元组
print("元组")
print(5 in (1, 2, 3, 4, 5, 6, 7))
print("Hi" in (1, 2, 3, 4, 5, 6, 7))
print("---------")
# 字符串
print("字符串")
print("5" in "1234567")
print("Hi" in "1234567")

```
        - 执行结果如下：

```Python
列表
True
False
---------
元组
True
False
---------
字符串
True
False
```

      - 2：
        - 注意，只有当元素的类型和值都完全一致，才算是有包含在序列中，比如数字“5”和字符串“"5"”
就是两种不同的元素。还有一点需要注意的是，如果判断字符串序列是否包含元素，则所参与运
算的元素必须是字符串。

```Python
# 错误
print(5 in "1234567")
#Python解释器要求如果“in”操作符的右边是字符串，那么左边也必须是字符串。
```

    #### 长度、最小值、最大值和求和：
      - Python提供了许多通用方法可以给存储数字的序列使用。

```Python
# 列表
x1 = [1, 2, 3, 4, 5, 6, 7]
print("列表")
print("列表长度", len(x1))
print("列表最小值", min(x1))
print("列表最大值", max(x1))
print("列表求和", sum(x1))
print("---------")
# 元组
x2 = (1, 2, 3, 4, 5, 6, 7)
print("元组")
print("元组长度", len(x2))
print("元组最小值", min(x2))
print("元组最大值", max(x2))
print("元组求和", sum(x2))
print("---------")
# 字符串
x3 = "1234567"
print("字符串")
print("字符串长度", len(x3))
print("字符串最小值", min(x3))
print("字符串最大值", max(x3))
```
      - 执行结果如下：

```Python
列表
列表长度 7
列表最小值 1
列表最大值 7
列表求和 28
---------
元组
元组长度 7
元组最小值 1
元组最大值 7
元组求和 28
---------
字符串
字符串长度 7
字符串最小值 1
字符串最大值 7

#注意：
#len函数可以获取序列的长度，min函数可以获取序列的最小值，
#max函数可以获取序列的最大值，sum函数可以对序列求和。但是要注意sum函数求和的要求是序列
#的元素必须都是int，由于字符串序列的元素都是字符串，所以sum函数无法对字符串序列求和。
```

  ### 列表：

    #### 列表更新：

      - 1：
        - 列表可以通过索引更新其中的元素，使用方法就和变量赋值一样方便。

```Python
l1 = [1, 2, 3, 4, 5]
print(l1 [2])
l1 [2] = "Hello"
print(l1)
```
        - 执行结果如下：

```Python
3
[1, 2, 'Hello', 4, 5]
```

      - 2：
        - 一个列表是可以存储不同类型的数据的，并且修改的新元素也不需要和原来的元素类型一致。
但是要注意，更新列表的索引必须是已存在的索引，不能对超出列表长度的索引更新元素。

```Python
l1 = [1, 2, 3, 4, 5]
l1 [10] = "Hello"
```

    #### 增加元素：

      - 1：
        - 如果想要添加新元素，可以使用append方法在列表的最后追加新元素。

```Python
l1 = [1, 2, 3, 4, 5]
l1.append("Hello")
print(l1)
```
        - 执行结果如下：

```Python
[1, 2, 3, 4, 5, 'Hello']
```
        - append直接在原来的列表上新增了一个元素。但是要注意，append每次只能新增一个元素

      - 2：
        - 如果想新增多个元素就要使用extend方法。

```Python
l1 = [1, 2, 3, 4, 5]
l1.append( [6, 7])
print("append")
print(l1)
print("------------------")
l2 = [1, 2, 3, 4, 5]
l2.extend( [6, 7])
print("extend")
print(l2)
```
        - 执行结果如下：

```Python
append
[1, 2, 3, 4, 5, [6, 7]]
------------------
extend
[1, 2, 3, 4, 5, 6, 7]
```

      - tips：
        - append无论后面是单个元素还是一个列表，都会把它当成一个新元素追加在原来的列表的后面，
而extend则会展开，把新列表拆开追加在原来的列表后面。

      - 3：
        - append和extend两种方法都是在列表的最后追加元素，方法insert可以在列表中间插入
元素

```Python
l1 = [1, 2, 3, 4, 5]
print(l1)
print("insert")
l1.insert(2, "Hello")
print(l1)

```
        - 执行结果如下：

```Python
[1, 2, 3, 4, 5]
insert
[1, 2, 'Hello', 3, 4, 5]
```

      - tips：
        - insert方法需要传递两个参数，第一个参数表示要插入的新元素的位置，第二个参数表示要插
入的新元素。insert和append一样，一次只能新增一个元素。

    #### 删除元素：

      - 1：
        - pop函数用于移除列表中的一个元素（默认是最后一个元素），并且返回该元素的值。

```Python
l1 = [1, 2, 3, 4, 5]
print(l1)
print("pop()")
r1 = l1.pop()
print("result", r1)
print("list", l1)
print("----------------")
l2 = [1, 2, 3, 4, 5]
print("pop(2)")
r2 = l2.pop(2)
print("result", r2)
print("list", l2)
```
        - 执行结果如下：

```Python
[1, 2, 3, 4, 5]
pop()
result 5
list [1, 2, 3, 4]
----------------
pop(2)
result 3
list [1, 2, 4, 5]

```
        - pop函数可以删除指定位置的元素，并且把这个元素作为返回值返回，
如果不指定位置则默认选择最后一个元素。

      - 2：
        - 不但可以根据位置删除元素，还可以根据元素内容来对元素进行删除。remove方法就提
供了这样的功能。

```Python
l1 = ["Hello", "Google", "Baidu", "QQ"]
print(l1)
print("remove")
l1.remove("Baidu")
print(l1)
```
        - 执行结果如下：

```Python
 ['Hello', 'Google', 'Baidu', 'QQ']
remove
 ['Hello', 'Google', 'QQ']
```
        - “remove”会删除查找到的第一个元素，并且没有返回值。

      - 3：
        - 不但可以使用列表自带的方法对列表元素进行删除，也可以使用关键字“del”来删除列表元素。

```Python
l1 = ["Hello", "Google", "Baidu", "QQ"]
print(l1)
print("del")
del l1 [2]
print(l1)

```
        - 执行结果如下：

```Python
['Hello', 'Google', 'Baidu', 'QQ']
del
['Hello', 'Google', 'QQ']
```
        - “del”删除了其中一个元素，元素数量从四个变成了三个。
“del”不仅可以删除列表的元素，还能删除其他元素

    #### 查找元素：

      - 1：
        - Python提供了index方法用于查找元素在列表中的索引位置

```Python
l1 = ["Hello", "Google", "Baidu", "QQ"]
print("Baidu index is", l1.index("Baidu"))
print("QQ index is", l1.index("QQ"))
```
        - 执行结果如下：

```Python
Baidu index is 2
QQ index is 3
```

      - 2：
        - 但是要注意，如果元素不在列表中，Python解释器就会输出错误信息。

```Python
# 错误
l1 = ["Hello", "Google", "Baidu", "QQ"]
print("Taobao index is", l1.index("Taobao"))
```

    #### 队列的其他操作

      - 1：
        - reverse方法可以反转队列，和“ [::-1]”类似，但是reverse方法修改的是原来的队列，并且没有返回值

```Python
l1 = [1, 2, 3, 4, 5]
print(l1)
print("reverse")
l1.reverse()
print(l1)
```
        - 执行结果如下：

```Python
[1, 2, 3, 4, 5]
reverse
[5, 4, 3, 2, 1]
```

      - 2：
        - count方法用于统计某个元素在列表中出现的次数。

```Python
l1 = ["Hello", "Google", "Baidu", "QQ", "01", "Hello"]
print(l1)
print(l1.count("Hello"))
print(l1.count("Taobao"))
```
        - 执行结果如下：

```Python
['Hello', 'Google', 'Baidu', 'QQ', '01', 'Hello']
2
0
```

  ### 元组：

    #### 定义元组

      - tips：
        - 元组与列表十分相似，大部分方法都通用，但是元组与列表的最大区别是列表可以修改、可
以读取、可以删除，而元组创建之后则不能修改，不能删除单个元素，但是可以删除整个元组。

      - 1：
        - 元组定义大体上和列表类似，定义元组时只需要用“(”和“)”把元素括起，并用“,”把元素
隔开就可以了

```Python
l1 = (1, 2, 3)
print(l1)
print(type(l1))
```
        - 执行结果如下：

```Python
(1, 2, 3)
<class 'tuple'>
```

      - 2：
        - 但是要注意，如果元组只有一个元素，则这个元素后面必须要有“,”，否则元素就还是其原
来的类型。

```Python
l1 = (1)
print(l1, type(l1))
l2 = (1,)
print(l2, type(l2))
l3 = ("Hello")
print(l3, type(l3))
l4 = ("Hello",)
print(l4, type(l4))
```
        - 执行结果如下：

```Python
1 <class 'int'>
(1,) <class 'tuple'>
Hello <class 'str'>
('Hello',) <class 'tuple'>
```
        - 如果只有一个元素，单单使用“()”是不够的，还需要在最后加上“,”，才能定义一个元组。

    #### 删除元组
      - 由于元组不能修改，所以元组也不能单独删除部分元素，要删除只能删除整个元组。

```Python
l1 = (1, 2, 3, 5)
del l1
# 错误
print(l1)
```
      - 运行这段代码，Python解释器会在“print”的时候输出错误提示“NameError: name 'l1' is not
defined”，这个提示说明了变量“l1”未定义，而我们成功删除了元组“l1”。

    #### 元组的其他操作

      - tips：
        - 元组虽然不能修改，但是列表所支持的查询方法基本上元组都支持。也正是因为元组不能修
改，所以元组的查询速度要比列表更快。

      - 1：
        - count方法用于统计某个元素在元组中出现的次数。

```Python
l1 = ("Hello", "Google", "Baidu", "QQ", "01", "Hello")
print(l1)
print(l1.count("Hello"))
print(l1.count("Taobao"))
```
        - 执行结果如下：

```Python
('Hello', 'Google', 'Baidu', 'QQ', '01', 'Hello')
2
0
```

      - 2：
        - index方法用于查找元素在元组中的索引位置

```Python
l1 = ("Hello", "Google", "Baidu", "QQ")
print("Baidu index is", l1.index("Baidu"))
print("QQ index is", l1.index("QQ"))
```
        - 执行结果如下：

```Python
Baidu index is 2
QQ index is 3
```

  ### 字典：

    #### 定义字典：

      - 1：
        - 字典（dict）类型就和它的名字一样，可以像查字典一样去查找。其他一些语言里也有类似的
类型，如PHP中的Array，Java中的HashMap。定义字典非常简单

```Python
english = {
 "we": "我们",
 "world": "世界",
 "company": "公司",
}
print(english, type(english))
```
        - 执行结果如下：

```Python
{'we': '我们', 'world': '世界', 'company': '公司'} <class 'dict'>
```

      - 2：
        - 字典的元素是成对出现的，每个元素都是由“:”和键值对（“:”左边的称为键或者Key，“:”右边的称为值或者Value）构成，
元素和元素之间用“,”分隔，整个字典用花括号“{}”包围。字典的键必须是唯一、不重复的，如果是空字典（一个元素都没有）则可以直接使用“{}”表示

```Python
empty = {}
print(empty, type(empty))

```
        - 执行结果如下：

```Python
{} <class 'dict'>
```

    #### 使用字典：

      - 1：
        - 在Python中，字典其实就是一组键值对。这在赋值字典变量的时候就可以看出，字典元素都
是成对出现的，每个元素必须要有键和对应的值。访问字典跟查字典一样，需要用键去“查找”
值

```Python
english = {
 "we": "我们",
 "world": "世界",
 "company": "公司",
}
print("world", english ["world"])
```
        - 执行结果如下：

```Python
world 世界
```

      - 2：
        - 从例子中可以看到，使用dict就像查字典一样，用类似列表索引的语法查找键对应的值。但是
要注意，这种方法只能获取已存在的键值对，如果尝试访问不存在的键，Python将会显示错误信
息。

```Python
english = {
 "we": "我们",
 "world": "世界",
 "company": "公司",
}
# 错误
print("city", english ["city"])
```

      - 3：
        - 字典和列表一样，都是一种可修改的结构，所以我们也能对字典进行修改。修改的方式和列
表有些类似

```Python
english = {
 "we": "我们",
 "world": "城市",
 "company": "公司",
}
print(english)
english ["world"] = "世界"
print(english)
```
        - 执行结果如下：

```Python
{'we': '我们', 'world': '城市', 'company': '公司'}
{'we': '我们', 'world': '世界', 'company': '公司'}
```

      - 4：
        - 字典新增元素和修改元素的语法是一样的。

```Python
english = {}
print(english)
english ["city"] = "城市"
print(english)

```
        - 执行结果如下：

```Python
{}
{'city': '城市'}
```

## 流程控制:

  ### if判断：

    ####  if语句：

      - 1：
        - 几乎所有的语言都有if语句，if语句按照条件选择执行不同的代码。Python的if语句格式如下：

```Python
if 表达式：
  语句1
  语句2
  ……
```

            注意示例中“语句1”“语句2”前的缩进（相对于if行有四个空格开头）不能省略。

      - 2：
        - 每条if语句的核心都是一个值是“True”或“False”的表达式，这种表达式被称为条件测试。
如果条件测试的值为“True”，Python就执行紧跟在if语句后面的代码块；
如果值为“False”，Python就忽略这些代码不去执行。

```Python
x = True
if x:
    print("It's True!")
```
        - 执行结果如下：

```Python
It's True!
```

        

        - 从执行结果来看，if语句中的代码块被执行，说明“x”的条件测试值是“True”。如果把“x”改成“False”：

```Python
x = False
if x:
    print("It's True!")

```

            这个例子的执行结果是没有输出的，说明代码块中的print语句没有被执行，表明“if”后的条
件测试值是“False”。

      - 3：
        - “if”后的条件测试不只支持布尔类型，后面也可以使用数字，例如：

```Python
x = 18
if x:
    print("x is", x)
```
        - 执行结果如下：

```Python
x is 18
```
        - 从执行结果来看，条件测试适用于数字。如果使用数字来作为“if”的判断条件，则只有数字
“0”的条件测试结果是“False”。例如：

```Python
x = 0
if x:
    print("x is not zero")
```
        - 这个例子的执行结果是没有输出的，说明代码块中的print语句没有被执行，表明“if”后的条
件测试值是“False”。

      - 4：
        - 如果条件测试的内容是字符串，则只有字符串是空字符串时条件测试的结果是“False”，其
余字符串都是“True”。

```Python
x = "Hello"
if x:
    print("x is", x)
```
        - 执行结果如下：

```Python
x is Hello
```

      - 5：

```Python
x = ""
if x:
    print("Hello World")
```
        - 这个例子的执行结果是没有输出的，说明代码块中的print语句没有被执行，表明“if”后的条件测试值是“False”。
        - 不单是字符串，条件测试中空列表、空元组、空字典也是“False”。

    #### else语句：
      - else语句很好理解，当“if”的条件测试为“False”的时候执行“else”后的语句，
“else”是“if”语句的可选项，并且不一定非要有“else”。
注意“else”不能单独出现，必须跟在“if”后面。

```Python
x = 0
if x:
    print("x is not zero")
else:
    print("x is zero")
```
      - 执行结果如下：

```Python
x is zero
```
      - 从这个例子可以看出：数字“0”的条件测试是“False”，所以“if”后的语句不会被执行，但是“else”后的语句正确执行了。

    #### elif语句：
      - 有时候可能会需要测试多个条件，单纯的“if…else”并不能满足所有需求，这种情况下就可
以使用“elif”。“elif”和“else”一样都是“if”的可选项，并且“elif”也不能单独出现，必须跟
在“if”后面。

```Python
x = 89
if x > 90:
    print("优")
elif x > 80:
    print("良")
elif x > 60:
    print("及格")
```
      - 执行结果如下：

```Python
良
```

      

      - 从执行的结果看，代码执行了第一个“elif”后面的语句。虽然“x”等于“89”满足“x>80”
和“x>60”，但是“if…elif”只会执行第一条条件测试是“True”的语句，其他内容都会被忽视。
注意：如果有“elif”，则“else”必须在最后，不能插在“elif”之前。

```Python
x = 49
if x > 90:
 print("优")
elif x > 80:
 print("良")
elif x > 60:
 print("及格")
else:
 print("不及格")
```
      - 执行结果如下：

```Python
不及格
```
      - 从执行结果看到，“x”变量不满足“if”和“elif”的条件，所以执行了“else”后的语句。

  ### 循环：

    #### while循环：

      - 1：
        - while循环是Python中最简单的循环语句，它的语法格式如下：

```Python
while表达式:
  语句1
  语句2
  ……
```
        - 注意示例中“语句1”“语句2”前的缩进（相对于while行有四个空格开头）不能省略。
        - 执行流程如下：

            ![](https://secure2.wostatic.cn/static/mtRNpgszTLmETksHckGUXU/image.png)

      - 2：
        - while语句后的表达式和if语句后的表达式一样，都是条件测试。只有条件测试的结果是
“True”时才会执行“while”循环体内的语句。例如：

```Python
x = 1
while x <= 10:
    print(x)
    x += 1
```
        - 执行结果如下：

```Python
1
2
3
4
5
6
7
8
9
10
```
        - 执行结果是打印出1～10的数字。注意“x+= 1”不能省略，否则会产生无限循环或者死循环，
因为如果没有“x+=1”，那么变量“x”将永远小于“10”，while语句中的“x <= 10”条件测试则
永远是“True”，那么“print(x)”将会一直执行下去，最终可能导致系统资源被耗尽。

    #### for循环：

      - 1:
        - for循环有个比while循环更丰富的作用，它的语法格式如下：

```Python
for变量 in 序列：
  语句1
  语句2
  ……
```
        - 执行流程如下：

            ![](https://secure2.wostatic.cn/static/vvavfpcNkYen2HUVDBRNY4/image.png)

      - 2:
        - 语法格式中的序列可以是列表、元组等可迭代对象。可迭代对象的概念将会在后续章节详细
展开介绍，本节先以列表和元组举例。例如：

```Python
for x in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10):
 print(x)
```
        - 执行结果如下：

```Python
1
2
3
4
5
6
7
8
9
10
```

      - 3:
        - range有两种使用方式，第一种是给定一个数字：

```Python
for x in range(10):
 print(x)
```
        - 第二种用法是给定range函数的开始和结束数字，并且定义增长步进（如果不定义则默认是1）

```Python
for x in range(1, 10):
 print(x)
```

    #### break和continue语句：
      - 前面介绍中的循环都会按部就班地一直执行下去，直到不满足条件，退出循环体。有时候可能情况比较复杂，
需要跳过或者退出循环体，这时候break和continue语句就派上用场了。break的作用是立即退出循环体，
直接结束循环。

```Python
for i in range(10):
 if i > 5:
   break
 print(i)
```
      - continue的作用和break有点类似，不过continue并不会退出循环体，而是跳过当前的循环体执行之后的循环。

```Python
for i in range(10):
 if i == 5:
   continue
 print(i)

```
